@startuml
'TODO: check serialisation for contained classes
skinparam linetype ortho
skinparam BackgroundColor #EEE

skinparam class {
    AttributeIconSize 0
    BackgroundColor #E5E5E5
    ArrowColor #666
    BorderColor #666
}

class GameManager implements Serialisable{
    - running_save: GameInstance
    - all_saves: ArrayList<GameInstance>
    + save(): void
    + load(): void
    + serialise(): void
    + deserialise(): void
    {static}- serialVersionUID: long
}

class GameInstance{
    'main class, contains everything relevant to the starting/stopping of the game.
    + helmet_list: ArrayList<Helmet>
    - player: Player
    - hero: Hero
    - gamemap: ArrayList<GameObject>
    - statistics: Stats

    + start(): void
    + stop(): void
    + pause(): void
    + resume(): void
    + exit(): void
    + resurrect(): void
    + game_over(): void
    + win(): void
}

class GameObject{
    - pos[]: float[2]
    - vel[]: float[2]
    - acc[]: float[2]

    + get_pos(): float[2]
    + set_vel(axis: int, value: float): void
    + set_acc(axis: int, value: float): void
    + move():void
}

class Hero extends GameObject implements Collidable{
    'contains player information: high scores, save games, etc
    'for serialisation/deserialisation(?)
    - available_weapons[]: Weapon[]
    - current_weapon: Weapon
    - current_helmet: Helmet
    - resurrected: boolean

    {method} <i>@Override</i>
    + collide(other: Collidable): void

    - collect_points(points: int)
    - die(): void
    + alive_status(): void
    - jump(): void
    - resurrect(): void
    + equip_helmet(helm: Helmet): void
    + equip_weapon(weapon: Weapon): void
}

interface Collidable <<interface>>{
    + void collide(other: Collidable): void
}

abstract class Chest extends GameObject implements Collidable{
    + <i>collect_chest(hero: Hero):void</i>
    + disappear():void
}

class Orc extends GameObject implements Collidable{
    - health : int
    - coin_count: int
    + sprite : ???

    {method}<i>@Override</i>
    +collide(other: Collidable):void

    + die(): int
    + get_hit(hero: Hero): void
    + is_alive(): boolean
    + smash_hero(hero: Hero): void
    - jump(): void
}
class GreenOrc extends Orc{
}
class RedOrc extends Orc{
}
class Boss extends Orc{
}

class WeaponChest extends Chest{
    {method} <i>@Override</i>
    collect_chest(hero: Hero): void
}
class CoinChest extends Chest{
    - coins_number: int
    {method} <i>@Override</i>
    collect_chest(hero: Hero): void
}

class Weapon implements Collectable{
    - level:int

    {method}<i>@Override</i>
    + get_collected(hero: Hero): void

    + use(): int
    + upgrade(): void
}

class FlyingWeapon extends GameObject implements Collidable{
    {method}<i>@Override</i>
    + collide(other: Collidable): void
}

class Coin extends GameObject implements Collectable {
    {method}<i>@Override</i>
    + get_collected(hero: Hero): void
}

interface Collectable <<interface>>{
    + get_collected(hero: Hero):void
}

class Platform extends GameObject implements Collidable{
    'boundaries of platform
    -start_position: int
    -end_position: int
    {method}<i>@Override</i>
    + collide(other: Collidable): void
}

class FallingPlatform extends Platform {
    + collapse(): void
}

class Helmet{
    - weapons: ArrayList<Weapon>
}

hide circle

Hero *--> Helmet
Helmet --> Weapon

'for Game
GameInstance "1 " *-- "1 " Hero
GameInstance "..* " *-- GameObject
GameManager "*..*" *-- GameInstance

'for Chests
WeaponChest "1      " *-- Weapon
CoinChest "1 .. * " *-- Coin
@enduml